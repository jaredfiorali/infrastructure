name: alloy
namespace: loki
deployment:
  enabled: false
service:
  enabled: false
networkpolicy:
  egress:
    internal: true
  ingress:
    namespaces:
      - monitoring
serviceAccount:
  enabled: false
podDisruptionBudget:
  enabled: false
configMap:
  enabled: true
  value: |-
    config.alloy: |
      logging {
        level  = "info"
        format = "logfmt"
      }

      // Loki write endpoint
      loki.write "fiorali" {
        endpoint {
          url = "http://loki-gateway.loki/loki/api/v1/push"
          tenant_id = "fiorali"
        }
      }

      // Kubernetes discovery
      // Pod discovery (DaemonSet, node-local)
      discovery.kubernetes "pods" {
        role = "pod"
        selectors {
          role  = "pod"
          field = "spec.nodeName=" + coalesce(env("HOSTNAME"), constants.hostname)
        }
      }

      // Cluster-wide discovery
      discovery.kubernetes "services" {
        role = "service"
        // No node filter; discovers all services cluster-wide
      }

      discovery.kubernetes "ingresses" {
        role = "ingress"
        // No node filter; discovers all ingresses cluster-wide
      }

      // Relabel rules for pod logs
      discovery.relabel "pod_logs" {
        targets = discovery.kubernetes.pods.targets

        // Standard labels
        rule {
          source_labels = ["__meta_kubernetes_namespace"]
          action = "replace"
          target_label = "namespace"
        }

        rule {
          source_labels = ["__meta_kubernetes_pod_name"]
          action = "replace"
          target_label = "pod"
        }

        rule {
          source_labels = ["__meta_kubernetes_pod_container_name"]
          action = "replace"
          target_label = "container"
        }

        rule {
          source_labels = ["__meta_kubernetes_pod_label_app_kubernetes_io_name"]
          action = "replace"
          target_label = "app"
        }

        // Job label: namespace/container
        rule {
          source_labels = ["__meta_kubernetes_namespace", "__meta_kubernetes_pod_container_name"]
          action = "replace"
          target_label = "job"
          separator = "/"
          replacement = "$1/$2"
        }

        // Path to container logs
        rule {
          source_labels = ["__meta_kubernetes_pod_uid", "__meta_kubernetes_pod_container_name"]
          action = "replace"
          target_label = "__path__"
          separator = "/"
          replacement = "/var/log/pods/*$1/$2/*.log"
        }

        // Container runtime
        rule {
          source_labels = ["__meta_kubernetes_pod_container_id"]
          action = "replace"
          target_label = "container_runtime"
          regex = "^(\\S+):\\/\\/.+$"
          replacement = "$1"
        }
      }

      // Pod logs source
      loki.source.kubernetes "pod_logs" {
        targets    = discovery.relabel.pod_logs.output
        forward_to = [loki.process.pod_logs.receiver]
      }

      // Pod logs processing
      loki.process "pod_logs" {
        stage.static_labels {
          values = {
            cluster     = "default",
            environment = "prod",
          }
        }
        forward_to = [loki.write.fiorali.receiver]
      }

      // Kubernetes events
      loki.source.kubernetes_events "cluster_events" {
        job_name   = "integrations/kubernetes/eventhandler"
        log_format = "logfmt"
        forward_to = [loki.process.cluster_events.receiver]
      }

      loki.process "cluster_events" {
        forward_to = [loki.write.fiorali.receiver]
        stage.static_labels {
          values = {
            cluster     = "default",
            environment = "prod",
          }
        }
        stage.labels {
          values = {
            event_type = "job",
          }
        }
      }

      // Node-local file logs (syslog)
      local.file_match "node_logs" {
        path_targets = [{
            __path__  = "/var/log/syslog",
            job       = "node/syslog",
            node_name = sys.env("HOSTNAME"),
            cluster   = "default",
        }]
      }

      loki.source.file "node_logs" {
        targets    = local.file_match.node_logs.targets
        forward_to = [loki.write.fiorali.receiver]
      }
